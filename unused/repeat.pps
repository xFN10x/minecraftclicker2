{"blockDat":{},"dynamicDat":{"dynamic_variables":[],"dynamic_myblocks":[]},"glsl":"#version 300 es\n//This is the default shader for the shader editor!\n//These functions are here and are written for the GLSL 3.0 specification.\n//You can revert it to GLSL 1.0 by removing the version number\n\n//our output for color\nout highp vec4 fragColor;\n//Base Variables\nattribute highp vec4 a_position;\nattribute highp vec4 a_color;\nattribute highp vec2 a_texCoord;\n\nvarying highp vec4 v_color;\nvarying highp vec2 v_texCoord;\n\nvarying highp float v_depth;\nuniform highp float u_timer;\nuniform highp mat4 u_transform;\n\n//Pen+ Textures\nuniform mediump vec2 u_res;\n\n//Base functions\n\n//Some missing math functions\nhighp float log10(highp float a) {\n  return log(a)/log(10.0);\n}\n\nhighp float eulernum(highp float a) {\n    return 2.718 * a;\n}\n\n//Psuedorandomness\nhighp vec4 pcg4d(highp vec4 v)\n{\n    v = v * 1664525.0 + 1013904223.0;\n    \n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n    \n    v.x += v.z*v.w;\n    v.y += v.y*v.x;\n    v.z += v.x*v.w;\n    v.w += v.y*v.x;\n    \n    return vec4(v);\n}\n\nhighp vec4 daveRandomRange(highp float lowR, highp float highR)\n{\n    lowp float r = (gl_FragCoord.x * 50.25313532) + (gl_FragCoord.y * 21.5453) + u_timer;\n    highp float randomizer = r*r/u_timer/5398932.234523;\n    return clamp(vec4(\n    fract(sin(mod(randomizer*(91.3458), 1440.0)) * 47453.5453),\n    fract(sin(mod(randomizer*(80.3458), 1440.0)) * 48456.5453),\n    fract(sin(mod(randomizer*(95.3458), 1440.0)) * 42457.5453),\n    fract(sin(mod(randomizer*(85.3458), 1440.0)) * 47553.5453)\n    ), lowR, highR);\n}\n\nhighp vec4 HSVToRGB(highp float hue, highp float saturation, highp float value, highp float a) {\n  highp float huePrime = mod(hue,360.0);\n  highp float c = (value/100.0) * (saturation/100.0);\n  highp float x = c * (1.0 - abs(mod(huePrime/60.0, 2.0) - 1.0));\n  highp float m = (value/100.0) - c;\n  highp float r = 0.0;\n  highp float g = 0.0;\n  highp float b = 0.0;\n  \n  if (huePrime >= 0.0 && huePrime < 60.0) {\n      r = c;\n      g = x;\n      b = 0.0;\n  } else if (huePrime >= 60.0 && huePrime < 120.0) {\n      r = x;\n      g = c;\n      b = 0.0;\n  } else if (huePrime >= 120.0 && huePrime < 180.0) {\n      r = 0.0;\n      g = c;\n      b = x;\n  } else if (huePrime >= 180.0 && huePrime < 240.0) {\n      r = 0.0;\n      g = x;\n      b = c;\n  } else if (huePrime >= 240.0 && huePrime < 300.0) {\n      r = x;\n      g = 0.0;\n      b = c;\n  } else if (huePrime >= 300.0 && huePrime < 360.0) {\n      r = c;\n      g = 0.0;\n      b = x;\n  }\n  r += m;\n  g += m;\n  b += m;\n  return vec4(r, g, b, a);\n}\n\nhighp vec4 rotation(highp vec4 invec4) {\n  return vec4(\n    (invec4.y) * u_transform[1][0] + (invec4.x) * u_transform[1][1],\n    (invec4.y) * u_transform[1][1] - (invec4.x) * u_transform[1][0],\n    invec4.zw\n  );\n}\nuniform sampler2D tx;\nuniform highp float directionX;\nuniform highp float directionY;\n\n//Fragment Shader\nvoid fragment() {\ngl_FragColor = v_color;\n\n// High precision directional movement factors\n//highp float directionX = 1.0;  // Set to -1.0 for movement in reverse direction (left/right)\n//highp float directionY = 0.5;  // Set to -1.0 for movement in reverse direction (up/down)\n\n// High precision angle calculation based on direction\nhighp float angle = atan(directionY, directionX);\n\n// High precision rotation matrix\nhighp mat2 rotationMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\n// High precision movement calculation (move in both directions)\nhighp vec2 movement = vec2(v_texCoord.x + directionX * u_timer, v_texCoord.y + directionY * u_timer);\n\n// Apply rotation after movement\nhighp vec2 rotatedTexCoord = rotationMatrix * (movement - 0.5) + 0.5;\n\n// Wrap the coordinates to stay within [0, 1] after rotation\nhighp vec2 wrappedTexCoord = mod(rotatedTexCoord, 1.0);\n\n// Sample the texture using wrapped coordinates\nfragColor = texture(tx, wrappedTexCoord);\n\n}//Vertex Shader\nvoid vertex() {\n  gl_Position = (rotation(a_position) + vec4(u_transform[0][2],u_transform[0][3],0,0)) * vec4(a_position.w * u_transform[0][0],a_position.w * -u_transform[0][1],1,1) - vec4(0,0,1,0);\n  v_color = a_color;\n  v_texCoord = a_texCoord;\n}","isText":true,"savedVarState":{}}